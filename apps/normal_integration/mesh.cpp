#include "mesh.h"

Mesh::Mesh(double width, double height, int res_x, int res_y)
{
    // set physical size of mesh
    this->width = width;
    this->height = height;

    // set poisson domain resolution
    this->res_x = res_x;
    this->res_y = res_y;

    // Build the parameterization mesh
    generate_structured_mesh(res_x, res_y, width, height, this->triangles, this->target_points);
    build_vertex_to_triangles();

    //circular_transform(this->target_points);

    // Duplicate mesh points
    for (int i=0; i<this->target_points.size(); i++) {
        this->source_points.push_back(this->target_points[i]);
    }
}

Mesh::~Mesh()
{
}

void find_perimeter_vertices(int nx, int ny, std::vector<int> &perimeter_vertices) {
    // Top row
    for (int i = 0; i < nx; ++i) {
        perimeter_vertices.push_back(i);
    }

    // Right column
    for (int i = nx - 1; i < nx * ny; i += nx) {
        perimeter_vertices.push_back(i);
    }

    // Bottom row
    for (int i = nx * (ny - 1) + nx - 1; i > nx * (ny - 1) - 1; --i) {
        perimeter_vertices.push_back(i);
    }

    // Left column
    for (int i = nx * (ny - 1) - nx; i > nx - 1; i -= nx) {
        perimeter_vertices.push_back(i);
    }
}

void save_solid_obj(std::vector<std::vector<double>> &front_points, std::vector<std::vector<double>> &back_points, std::vector<std::vector<int>> &triangles, double thickness, double width, double height, int res_x, int res_y, const std::string& filename) {
    int num_points = back_points.size();

    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return;
    }

    // Find maximum height
    double max_h = 0;
    for (int i=0; i<num_points; i++) {
        if (back_points[i][2] > max_h) {
            max_h = back_points[i][2];
        }
    }

    // file << "# Generated by the software algorithm written by Dylan Missuwe" << "\n";
    // file << "# The algorithm used to create the lens is based on the paper " 
    //     << "\"Poisson-Based Continuous Surface Generation for Goal-Based Caustics\" " 
    //     << "by Yue et al (2014)" << "\n";

    // Flat mesh verts on the top
    for (const auto& point : front_points) {
        // file << "v " << point[0] << " " << point[1] << " " << max_h + thickness << "\n";
        file << "v " << point[0] << " " << point[1] << " " << thickness << "\n";
    }

    // Curved mesh verts on the bottom
    for (const auto& point : back_points) {
        file << "v " << point[0] << " " << point[1] << " " << point[2] << "\n";
    }

    // Flat mesh triangles on the top
    for (const auto& triangle : triangles) {
        file << "f " << triangle[0] + 1 << " " << triangle[1] + 1 << " " << triangle[2] + 1 << "\n";
    }

    // Curved mesh triangles on the bottom
    for (const auto& triangle : triangles) {
        file << "f " << triangle[0] + num_points + 1 << " " << triangle[2] + num_points + 1 << " " << triangle[1] + num_points + 1 << "\n";
    }

    // Generate triangles connecting top and bottom mesh
    std::vector<int> perimeter_verts;
    find_perimeter_vertices(res_x, res_y, perimeter_verts);

    for (size_t i = 0; i < perimeter_verts.size(); ++i) {
        int top_idx = perimeter_verts[i];
        int bottom_idx = perimeter_verts[i] + num_points;
        int next_top_idx = perimeter_verts[(i + 1) % perimeter_verts.size()];
        int next_bottom_idx = perimeter_verts[(i + 1) % perimeter_verts.size()] + num_points;


        file << "f " << top_idx + 1 << " " << bottom_idx + 1 << " " << next_bottom_idx + 1 << "\n";
        file << "f " << top_idx + 1 << " " << next_bottom_idx + 1 << " " << next_top_idx + 1 << "\n";
        //file << "f " << top_idx + 1 << " " << next_bottom_idx + 1 << " " << bottom_idx + 1 << "\n";
        //file << "f " << top_idx + 1 << " " << next_top_idx + 1 << " " << next_bottom_idx + 1 << "\n";
    }

    //std::cout << "Exported model \"" << filename << "\"" << std::endl;
}

// generates a structured triangulation used for the parameterization
void Mesh::generate_structured_mesh(int nx, int ny, double width, double height, std::vector<std::vector<int>> &triangles, std::vector<std::vector<double>> &points) {
    printf("%i, %i, %f, %f\r\n", nx, ny, width, height);
    // Generate points
    for (int i = 0; i < ny; ++i) {
        for (int j = 0; j < nx; ++j) {
            double x = static_cast<double>(j) * width / (nx - 1);
            double y = static_cast<double>(i) * height / (ny - 1);
            points.push_back({x, y, 0.0});
        }
    }

    // Generate triangles
    for (int i = 0; i < ny - 1; ++i) {
        for (int j = 0; j < nx - 1; ++j) {
            int idx = i * nx + j;
            triangles.push_back({idx, idx + 1, idx + nx});
            triangles.push_back({idx + nx, idx + 1, idx + nx + 1});
        }
    }
}

// transforms a square grid into a circular grid -> to support circular lenses in the future
/*void Mesh::circular_transform(std::vector<std::vector<double>> &input_points) {
    for (int i = 0; i < input_points.size(); i++) {
        double x = input_points[i][0] - this->width/2.0f;
        double y = input_points[i][1] - this->height/2.0f;

        input_points[i][0] = x * sqrt(1.0 - 2.0*(y * y));
        input_points[i][1] = y * sqrt(1.0 - 2.0*(x * x));

        input_points[i][0] += this->width/2.0f;
        input_points[i][1] += this->height/2.0f;
    }
}*/

std::vector<std::vector<double>> Mesh::circular_transform(std::vector<std::vector<double>> &input_points) {
    std::vector<std::vector<double>> transformed_points;
    for (int i = 0; i < input_points.size(); i++) {
        std::vector<double> transformed_point(3);

        double x = input_points[i][0] - this->width/2.0f;
        double y = input_points[i][1] - this->height/2.0f;

        transformed_point[0] = x * sqrt(1.0 - 2.0*(y * y));
        transformed_point[1] = y * sqrt(1.0 - 2.0*(x * x));

        transformed_point[0] += this->width/2.0f;
        transformed_point[1] += this->height/2.0f;
        transformed_point[2] = input_points[i][2];

        transformed_points.push_back(transformed_point);
    }
    return transformed_points;
}

// build mapping from vertices to adjecent triangles -> used for creating dual cells
void Mesh::build_vertex_to_triangles() {
    for (int i = 0; i < this->triangles.size(); ++i) {
        const std::vector<int>& triangle = this->triangles[i];
        
        for (int vertex : triangle) {
            if (this->vertex_to_triangles.find(vertex) == this->vertex_to_triangles.end()) {
                this->vertex_to_triangles[vertex] = std::vector<int>();
            }

            this->vertex_to_triangles[vertex].push_back(i);
        }
    }
}

// find triangles and edges connected to a specific vertex by index
std::pair<std::vector<std::pair<int, int>>, std::vector<int>> Mesh::find_adjacent_elements(int vertex_index) {
    std::unordered_set<std::pair<int, int>, HashPair> adjacent_edges;
    std::unordered_set<int> adjacent_triangles;

    // Find triangles containing the vertex
    auto triangles_containing_vertex = vertex_to_triangles.find(vertex_index);
    if (triangles_containing_vertex != vertex_to_triangles.end()) {
        for (int triangle_index : triangles_containing_vertex->second) {
            adjacent_triangles.insert(triangle_index);
            const std::vector<int>& triangle = triangles[triangle_index];

            // Find edges directly connected to the vertex
            for (int j = 0; j < 3; ++j) {
                std::pair<int, int> edge = std::make_pair(triangle[j], triangle[(j + 1) % 3]);
                if (vertex_index == edge.first || vertex_index == edge.second) {
                    adjacent_edges.insert(std::make_pair(std::min(edge.first, edge.second), std::max(edge.first, edge.second)));
                }
            }
        }
    }

    // Convert sets to vectors
    std::vector<std::pair<int, int>> adjacent_edges_vector(adjacent_edges.begin(), adjacent_edges.end());
    std::vector<int> adjacent_triangles_vector(adjacent_triangles.begin(), adjacent_triangles.end());

    return std::make_pair(adjacent_edges_vector, adjacent_triangles_vector);
}

double calculate_polygon_area_vec(const std::vector<std::vector<double>> input_polygon) {
    if (input_polygon.size() < 3) {
        return 0.0;
    }

	int n = input_polygon.size();
    double area = 0.0;

    for (int i = 0; i < n; i++) {
		double x1 = input_polygon[i][0];
		double y1 = input_polygon[i][1];
		double x2 = input_polygon[(i + 1) % n][0];
		double y2 = input_polygon[(i + 1) % n][1];
        area += (x1 * y2) - (x2 * y1);
    }

    // Take the absolute value and divide by 2
    area = 0.5 * (area);

    return area;
}

// Find neighboring vertices by vertex index
void Mesh::find_vertex_connectivity(int vertex_index, std::vector<int>& neighborList, std::vector<int>& neighborMap, const std::vector<int>& mask_indices) {
    std::unordered_set<int> neighboring_vertices;

    // Find triangles containing the vertex
    auto triangles_containing_vertex = vertex_to_triangles.find(vertex_index);
    if (triangles_containing_vertex != vertex_to_triangles.end()) {
        // Iterate over each triangle that contains the vertex
        for (int triangle_index : triangles_containing_vertex->second) {
            const std::vector<int>& triangle = triangles[triangle_index];

            // Find the other vertices in the same triangle
            for (int j = 0; j < 3; ++j) {
                if (triangle[j] != vertex_index) {
                    neighboring_vertices.insert(triangle[j]);  // Collect unique neighbors
                }
            }
        }

        // Convert set to vector to return unique neighboring vertices
        neighborList.clear();
        for (int neighbor : neighboring_vertices) {
            if (mask_indices[neighbor] == 1) {
                neighborList.push_back(neighbor);
            }
        }

        // Now construct neighborMap, ensuring pairs of neighbors are stored correctly
        for (int triangle_index : triangles_containing_vertex->second) {
            const std::vector<int>& triangle = triangles[triangle_index];
            
            // Store indices of the two neighbors that form a face with the current vertex
            std::vector<int> other_vertices;
            for (int j = 0; j < 3; ++j) {
                if (triangle[j] != vertex_index && mask_indices[triangle[j]] == 1) {
                    other_vertices.push_back(triangle[j]);
                }
            }

            // We should always have exactly 2 "other vertices" per triangle containing this vertex
            if (other_vertices.size() == 2) {
                int v1_idx = other_vertices[0];
                int v2_idx = other_vertices[1];

                // Find the indices of these vertices in neighborList and add to neighborMap
                for (int i = 0; i < neighborList.size(); ++i) {
                    if (neighborList[i] == v1_idx) {
                        neighborMap.push_back(i);  // Add index of the first neighbor
                    }
                    if (neighborList[i] == v2_idx) {
                        neighborMap.push_back(i);  // Add index of the second neighbor
                    }
                }

                // Optionally, check triangle area to ensure correct orientation
                std::vector<std::vector<double>> triangle = {
                    source_points[vertex_index],  // Current vertex
                    source_points[v1_idx],        // First neighbor
                    source_points[v2_idx]         // Second neighbor
                };
                double area = calculate_polygon_area_vec(triangle);

                // Swap the last two neighborMap entries if the area is negative (to correct orientation)
                if (area < 0.0) {
                    std::swap(neighborMap[neighborMap.size() - 1], neighborMap[neighborMap.size() - 2]);
                }
            }
        }
    }
}

void Mesh::get_vertex_neighbor_ids(int vertex_id, int &left_vertex, int &right_vertex, int &top_vertex, int &bottom_vertex) {
    int y = vertex_id / res_x;
    int x = vertex_id % res_x;

    if (x != 0) {
        left_vertex = (y) * res_x + (x - 1); // vertex_id - 1
    } else {
        left_vertex = -1;
    }

    if (y != 0) {
        top_vertex = (y - 1) * res_x + (x); // vertex_id - res_x
    } else {
        top_vertex = -1;
    }

    if (x != res_x - 1) {
        right_vertex = (y) * res_x + (x + 1); // vertex_id + 1
    } else {
        right_vertex = -1;
    }

    if (y != res_y - 1) {
        bottom_vertex = (y + 1) * res_x + (x); // vertex_id + res_x
    } else {
        bottom_vertex = -1;
    }
}

std::vector<double> normalize(std::vector<double> p1) {
    std::vector<double> vec(3);
    double squared_len = 0;
    for (int i=0; i<p1.size(); i++) {
        squared_len += p1[i] * p1[i];
    }

    double len = std::sqrt(squared_len);

    for (int i=0; i<p1.size(); i++) {
        vec[i] = p1[i] / len;
    }

    return vec;
}

// calculate target vertex normals for refractive caustics
std::vector<std::vector<double>> Mesh::calculate_refractive_normals_uniform(std::vector<std::vector<double>> target_pts, double focal_len, double refractive_index) {  
    std::vector<double> x_normals;
    std::vector<double> y_normals;
    std::vector<double> z_normals;

    // n = (t - µi) / ||(t - µi)||
    // where:
    // n = surface normal
    // t = transmitted ray normal
    // i = incident ray normal
    // µ = refraction coefficient

    //std::vector<double> point_src = {0, 0, -20.0f};

    std::vector<double> incident = {0.0f, 0.0f, 1.0f};

    for (int i=0; i<this->target_points.size(); i++) {
        std::vector<double> transmitted = {
            target_pts[i][0] - this->source_points[i][0],
            target_pts[i][1] - this->source_points[i][1],
            target_pts[i][2] - this->source_points[i][2]  + focal_len
        };

        //std::vector<double> incident = {0.0f, 0.0f, 0.0f};
        //incident[0] = this->target_points[i][0] - point_src[0];
        //incident[1] = this->target_points[i][1] - point_src[1];
        //incident[2] = this->target_points[i][2] - point_src[2];

        transmitted = normalize(transmitted);
        incident = normalize(incident);

        // t - µi
        double x_normal = transmitted[0] - incident[0] * refractive_index;
        double y_normal = transmitted[1] - incident[1] * refractive_index;
        double z_normal = transmitted[2] - incident[2] * refractive_index;
        
        std::vector<double> normal = {-x_normal, -y_normal, z_normal};

        normal = normalize(normal);

        // (t - µi) / ||(t - µi)||
        
        /*
        x_normals.push_back(normal[0]);
        y_normals.push_back(normal[1]);
        z_normals.push_back(normal[2]);
        //*/

        x_normals.push_back(normal[0]);
        y_normals.push_back(normal[1]);
        z_normals.push_back(normal[2]);
    }

    return {x_normals, y_normals, z_normals};
}

void Mesh::save_solid_obj_source(double thickness, const std::string& filename) {
    save_solid_obj(this->source_points, this->source_points, this->triangles, thickness, this->width, this->height, this->res_x, this->res_y, filename);
}

void Mesh::save_solid_obj_target(double thickness, const std::string& filename) {
    save_solid_obj(this->target_points, this->source_points, this->triangles, thickness, this->width, this->height, this->res_x, this->res_y, filename);
}

bool Mesh::is_border(int vertex_id) {
    int y = vertex_id / res_x;
    int x = vertex_id % res_x;

    if (x == 0) {
        return true;
    }

    if (y == 0) {
        return true;
    }

    if (x == res_x - 1) {
        return true;
    }

    if (y == res_y - 1) {
        return true;
    }

    return false;
}